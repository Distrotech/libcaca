/*
 *  libcucul      Canvas for ultrafast compositing of Unicode letters
 *  Copyright (c) 2002-2006 Sam Hocevar <sam@zoy.org>
 *                All Rights Reserved
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the Do What The Fuck You Want To
 *  Public License, Version 2, as published by Sam Hocevar. See
 *  http://sam.zoy.org/wtfpl/COPYING for more details.
 */

/** \file export_html.c
 *  \version \$Id$
 *  \author Sam Hocevar <sam@zoy.org>
 *  \author Jean-Yves Lamoureux <jylam@lnxscene.org>
 *  \brief Export function
 *
 *  This file contains export functions for HTML and HTML3
 */

#include "config.h"

#if !defined(__KERNEL__)
#   include <stdlib.h>
#   include <stdio.h>
#   include <string.h>
#endif

#include "cucul.h"
#include "cucul_internals.h"

/** \brief Generate HTML representation of current image.
 *
 *  This function generates and returns the HTML representation of
 *  the current image.
 */
void _cucul_get_html(cucul_t *qq, struct cucul_export *ex)
{
    static int const palette[] =
    {
        0x000, 0x008, 0x080, 0x088, 0x800, 0x808, 0x880, 0x888,
        0x444, 0x44f, 0x4f4, 0x4ff, 0xf44, 0xf4f, 0xff4, 0xfff,
    };
    char *cur;
    unsigned int x, y, len;

    /* The CSS palette: roughly 13000 bytes
     * A line: 7 chars for "<br />\n"
     * A glyph: 18 chars for "<span class='bxx'>"
     *          up to 9 chars for "&#xxxxxx;", far less for pure ASCII
     *          7 chars for "</span>" */
    ex->size = 13000 + qq->height * (7 + qq->width * (18 + 9 + 7));
    ex->buffer = malloc(ex->size);

    cur = ex->buffer;

    /* HTML header */
    cur += sprintf(cur, "<html>\n<head>\n<title>Generated by libcaca %s</title>\n", VERSION);

    /* CSS */
    cur += sprintf(cur, "<style>\n");
    cur += sprintf(cur, ".caca { font-family: monospace, fixed; font-weight: bold; }");
    for(x = 0; x < 0x100; x++)
    {
        cur += sprintf(cur, ".b%02x { color:#%03x; background-color:#%03x; }\n",
                       x, palette[x & 0xf ], palette[x >> 4]);
    }
    cur += sprintf(cur, "</style>\n</head>\n<body>\n");

    cur += sprintf(cur, "<div cellpadding='0' cellspacing='0' style='%s'>\n",
                        "font-family: monospace, fixed; font-weight: bold;");

    for(y = 0; y < qq->height; y++)
    {
        uint32_t *lineattr = qq->attr + y * qq->width;
        uint32_t *linechar = qq->chars + y * qq->width;

        for(x = 0; x < qq->width; x += len)
        {
            cur += sprintf(cur, "<span class='b%02x'>",
                           _cucul_argb32_to_ansi8(lineattr[x]));

            for(len = 0;
                x + len < qq->width && lineattr[x + len] == lineattr[x];
                len++)
            {
                if(linechar[x + len] <= 0x00000020)
                    cur += sprintf(cur, "&nbsp;");
                else if(linechar[x + len] < 0x00000080)
                    cur += sprintf(cur, "%c", linechar[x + len]);
                else
                    cur += sprintf(cur, "&#%i;", linechar[x + len]);
            }
            cur += sprintf(cur, "</span>");
        }
        /* New line */
        cur += sprintf(cur, "<br />\n");
    }

    cur += sprintf(cur, "</div></body></html>\n");

    /* Crop to really used size */
    ex->size = strlen(ex->buffer) + 1;
    ex->buffer = realloc(ex->buffer, ex->size);
}


/** \brief Generate HTML3 representation of current image.
 *
 *  This function generates and returns the HTML3 representation of
 *  the current image. It is way bigger than cucul_get_html(), but
 *  permits viewing in old browsers (or limited ones such as links)
 *  Won't work under gecko (mozilla rendering engine) unless you set
 *  a correct header.
 */
void _cucul_get_html3(cucul_t *qq, struct cucul_export *ex)
{
    static int const palette[] =
    {
        0x000000, 0x000088, 0x008800, 0x008888,
        0x880000, 0x880088, 0x888800, 0x888888,
        0x444444, 0x4444ff, 0x44ff44, 0x44ffff,
        0xff4444, 0xff44ff, 0xffff44, 0xffffff,
    };

    char *cur;
    unsigned int x, y, len;

    /* The CSS palette: roughly 13000 bytes
     * A line: 10 chars for "<tr></tr>\n"
     * A glyph: 40 chars for "<td bgcolor=#xxxxxx><font color=#xxxxxx>"
     *          up to 9 chars for "&#xxxxxx;", far less for pure ASCII
     *          12 chars for "</font></td>" */
    ex->size = 13000 + qq->height * (10 + qq->width * (40 + 9 + 12));
    ex->buffer = malloc(ex->size);

    cur = ex->buffer;

    /* Table */
    cur += sprintf(cur, "<table cols='%d' cellpadding='0' cellspacing='0'>\n",
                        qq->height);

    for(y = 0; y < qq->height; y++)
    {
        uint32_t *lineattr = qq->attr + y * qq->width;
        uint32_t *linechar = qq->chars + y * qq->width;

        cur += sprintf(cur, "<tr>");

        for(x = 0; x < qq->width; x += len)
        {
            unsigned int i;

            /* Use colspan option to factorize cells with same attributes
             * (see below) */
            len = 1;
            while(x + len < qq->width && lineattr[x + len] == lineattr[x])
                len++;

            cur += sprintf(cur, "<td bgcolor=#%06x",
                           palette[_cucul_argb32_to_ansi4bg(lineattr[x])]);

            if(len > 1)
                cur += sprintf(cur, " colspan=%d", len);

            cur += sprintf(cur, "><font color=#%06x>",
                           palette[_cucul_argb32_to_ansi4fg(lineattr[x])]);

            for(i = 0; i < len; i++)
            {
                if(linechar[x + i] <= 0x00000020)
                    cur += sprintf(cur, "&nbsp;");
                else if(linechar[x + i] < 0x00000080)
                    cur += sprintf(cur, "%c", linechar[x + i]);
                else
                    cur += sprintf(cur, "&#%i;", linechar[x + i]);
            }

            cur += sprintf(cur, "</font></td>");
        }
        cur += sprintf(cur, "</tr>\n");
    }

    /* Footer */
    cur += sprintf(cur, "</table>\n");

    /* Crop to really used size */
    ex->size = (uintptr_t)(cur - ex->buffer);
    ex->buffer = realloc(ex->buffer, ex->size);
}


